        在内核源代码的 init/ 目录中只有一个 main.c 文件，系统在执行完 boot/ 目录中的 head.s 程序后就会将执行权交给 main.c,该程序虽然不长，但却包括了内核初始化的所有工作。

 #### 7.1.1 功能描述
        main.c 程序首先利用了前面 setup.s 程序取得的系统参数设置系统的根文件设备号以及一些内存全局变量。
        这些内存变量指明了主内存的开始地址、系统所拥有的内存容量和作为高速缓冲区内存的末端地址，如果还定义了虚拟盘(RAMDISK),则主内存适当减少。
        整个内存的映像示意图。

 | 内核程序 | 高速缓冲 | 虚拟盘 |             主内存区               |
 
- 高速缓冲部分还要扣除被显存和ROM BIOS 占用的部分，高速缓冲是用于磁盘等块设备临时存放数据的地方，以1K(1024)字节为一个数据块单位
- 主内存区域的内存管理模块 mm 通过分页机制进行管理分配，以 4K 自己为一个内存页单位
- 内核程序可以自由访问高速缓冲中的数据，但需要通过 mm 才能使用分配到的内存页面
    
        然后，内核进行所有方面的硬件初始化工作，包括陷阱门、块设备、字符设备和 tty,还包括人工设置第一个任务(task 0),待所有初始化工作完成后程序就设置中断允许
 标志以开启中断，并切换到任务 0 中运行。
        
        在整个内核完成初始化后，内核将执行权切换到了用户模式(任务0)，也即CPU从 0 特权级切换到了第 3 特权级，此时 main.c 的主程序就工作在任务 0 中，然后系统
第一次调用进程创建函数 fork(),创建出一个用于运行 init() 的子进程(通常被称为 init 进程)

```
idle进程(进程0别称)
进程0(任务0):     系统初始化  -->  对物理内存各部分进行功能划分与分配 -->  系统各部分初始化，包括对任务 0 初始化  -->  移到任务 0 中执行  -->  创建进程 1 (init)  --> 空闲时执行 pause() 
                                                                                                                                                                                                                                |
                                  -------------------------------------------------------------------------------------------------------------
                                  |
进程1(init进程):   加载根文件系统  -->   设置终端标准 IO  -->  创建进程 2 -->  循环等待进程 2 退出   -->  创建子进程   -->  循环等待进程退出   --     <----
                                                                                             |                                |                               |       |                                         |            |
                                  ----------------------------------         --------------                               <---------------<-----------             |
                                  |                                                                   |                                                               |                                                      |
进程2:               输入定向到 rc 文件    -->    执行 shell 处理 rc   -->   退出                                                            |                                                      |
                                                                                                                                                                      |                                                      |                                                         
                                                                                                                                                                      |                                                      |
进程n:                                                                                                                                                    设置终端标志IO  -->  执行 shell --> 退出 -->
```

- main.c 程序首先确定如何分配使用系统物理内存，然后调用内核各部分的初始化函数分别对内存管理、中断处理、块设备和字符设备、进程管理以及硬盘和软盘硬件进行初始化处理。
- 此后，程序把自己"手工"移动到任务 0 (进程0)中运行，并使 fork() 调用首次创建出进程1 (init进程)，并在其中调用 init() 函数。该函数中程序将继续进行应用环境的初始化并执行 shell 登录程序，
而原进程 0 则会在系统空闲时被调度执行，因此进程 0 通常也被称为 idle 进程。此时进程 0 仅执行 pause() 系统调用，并又会调用调度函数。

- init() 函数的功能可分为4个部分:
   (1)安装根文件系统
   (2)显示系统信息
   (3)运行系统初始资源配置文件 rc 中的命令
   (4)执行用户登录 shell 程序

      代码首先调用系统调用 setup(),用来收集硬盘设备分区表信息并安装根文件系统，在安装根文件系统之前，系统会先判断是否需要先建立虚拟盘。若编译内核时设置了虚拟盘的大小，并在前面内核初始化
过程中已经开辟了一块内存用作虚拟盘，则内核就会首先尝试把根文件系统加载到内存的虚拟盘中。
        然后 init() 打开一个终端设备 tty0, 并复制其文件描述符以产生标准输入 stdin、标准输出 stdout 和 错误输出 stderr 设备。内核随后利用这些描述符在终端上显示一些系统信息，例如高速缓冲区中缓冲
块总数、主内存区空闲内存总字节数等。

- 0号进程就是初始进程，用于执行 main 函数，它会产生 1 号进程运行 init,以后的工作就由 1 号进程来完成了

#### 由系统模式转向用户模式
        在调用 move_to_user_mode 之前，main 函数一直在系统状态下运行，但是以后的进程是应该在用户模式下运行的，因此要在调用 fork() 之前将程序的运行模式转变为用户模式。
 方法是模拟中断返回，我们知道在用户模式的时候，如果发生中断会调用系统的中断服务程序。中断服务程序是运行在系统模式下的，因此会发生栈转换。当中断返回的时候，会恢复到
 中断之前的状态，这就包括了将运行模式转换为用户模式。中断的处理不过是压栈而已，因此我们可以利用压栈来模拟中断，然后，用一个返回指令来完成现场恢复的工作。


